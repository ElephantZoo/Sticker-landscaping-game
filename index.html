<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Êó†ÈôêÁîªÂ∏ÉÂàõ‰ΩúÂ∑•ÂÖ∑ Pro (Â¢ûÂº∫Áâà)</title>
    <style>
      :root {
        --bg-color: #f8fafc;
        --sidebar-width: 340px;
        --accent-primary: #3b82f6;
        --accent-secondary: #f59e0b;
        --text-main: #1e293b;
        --text-sub: #64748b;
        --glass-bg: rgba(255, 255, 255, 0.75);
        --glass-border: 1px solid rgba(255, 255, 255, 0.8);
        --ui-shadow:
          0 4px 20px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
        --radius-lg: 16px;
        --radius-md: 10px;
        --accent-deco: #3b82f6;
        --accent-bg: #f59e0b;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        user-select: none;
        -webkit-user-drag: none;
        -webkit-touch-callout: none;
        outline: none;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-main);
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        cursor: default;
      }

      /* Âè™ÊúâÂΩìÊåâ‰ΩèÁ©∫Ê†ºÊó∂Ôºåbody Âº∫Âà∂ÊâãÂûã */
      body.space-pressed #viewport {
        cursor: grab !important;
      }
      body.space-pressed #viewport:active {
        cursor: grabbing !important;
      }

      #viewport {
        flex: 1;
        position: relative;
        overflow: hidden;
        cursor: grab;
        background-color: #f1f5f9;
        background-image: radial-gradient(#cbd5e1 1.5px, transparent 1.5px);
        background-size: 24px 24px;
        touch-action: none;
      }
      #viewport:active {
        cursor: grabbing;
      }

      #world {
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 0;
        transform-origin: 0 0;
        will-change: transform;
      }

      #layer-container-bg {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 10;
      }
      #layer-container-deco {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 20;
      }

      #layer-container-deco.layer-locked {
        pointer-events: none !important;
        opacity: 0.3;
        transition: opacity 0.3s;
      }
      #layer-container-bg.layer-locked {
        pointer-events: none !important;
        opacity: 1;
        filter: none;
        transition: opacity 0.3s;
      }

      /* --- È°∂ÈÉ®Â∑•ÂÖ∑Ê†è --- */
      #top-bar {
        position: absolute;
        top: 24px;
        right: calc(var(--sidebar-width) + 24px);
        display: flex;
        gap: 12px;
        align-items: center;
        z-index: 200;
        padding: 10px 16px;
        background: var(--glass-bg);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border: var(--glass-border);
        border-radius: var(--radius-lg);
        box-shadow: var(--ui-shadow);
      }

      #top-bar > div[style*="width: 1px"] {
        background: #cbd5e1 !important;
        height: 20px;
        margin: 0 8px !important;
      }

      .ui-btn {
        background: transparent;
        border: 1px solid transparent;
        padding: 8px 12px;
        border-radius: var(--radius-md);
        font-size: 13px;
        font-weight: 600;
        color: var(--text-sub);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s ease;
        white-space: nowrap;
      }
      .ui-btn:hover:not(:disabled) {
        background: rgba(0, 0, 0, 0.04);
        color: var(--text-main);
        transform: translateY(-1px);
      }
      .ui-btn:active:not(:disabled) {
        transform: translateY(1px);
      }
      .ui-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .mode-btn {
        background: #f1f5f9;
        color: var(--text-sub);
      }
      .mode-btn.active {
        background: #1e293b;
        color: #fff;
        box-shadow: 0 4px 12px rgba(30, 41, 59, 0.3);
      }
      .mode-btn[data-mode="bg"].active {
        background: var(--accent-secondary);
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
      }
      .mode-btn[data-mode="deco"].active {
        background: var(--accent-primary);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }

      .ui-btn.primary {
        background: #eff6ff;
        color: var(--accent-primary);
        border: 1px solid #bfdbfe;
      }
      .ui-btn.primary:hover {
        background: #dbeafe;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
      }
      .ui-btn.danger {
        color: #ef4444;
      }
      .ui-btn.danger:hover {
        background: #fef2f2;
      }

      /* ÊªëÂä®Êù°ÈÄöÁî® */
      .ui-control-group {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
        padding: 0 4px;
      }
      .ui-control-group label {
        font-size: 10px;
        font-weight: 700;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      input[type="range"] {
        -webkit-appearance: none;
        width: 100px;
        height: 4px;
        background: #e2e8f0;
        border-radius: 4px;
        margin: 6px 0;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        border: 1px solid #cbd5e1;
        cursor: pointer;
        transition: transform 0.1s;
      }
      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        border-color: var(--accent-primary);
      }

      /* --- ‰æßËæπÊ†è --- */
      #sidebar {
        width: var(--sidebar-width);
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        border-left: 1px solid rgba(0, 0, 0, 0.05);
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.02);
        display: flex;
        flex-direction: row;
        z-index: 300;
        position: relative;
        transition: background-color 0.2s;
      }
      #sidebar.drag-over {
        background-color: #fee2e2;
        border-left-color: #ef4444;
      }

      #sidebar-left-control {
        width: 60px;
        background: transparent;
        border-right: 1px solid #f1f5f9;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px 0;
        gap: 15px;
        height: 100%;
      }

      .layer-slider-container {
        flex: 1;
        width: 100%;
        display: flex;
        justify-content: center;
        min-height: 0;
      }
      input[type="range"].big-vertical-range {
        -webkit-appearance: none;
        writing-mode: bt-lr;
        appearance: slider-vertical;
        width: 6px;
        height: 100%;
        background: #f1f5f9;
        border-radius: 10px;
        cursor: ns-resize;
      }
      input[type="range"].big-vertical-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        background: #fff;
        border: 2px solid var(--accent-primary);
        border-radius: 50%;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        cursor: grab;
      }
      #sidebar.mode-bg
        input[type="range"].big-vertical-range::-webkit-slider-thumb {
        border-color: var(--accent-secondary);
      }

      .layer-label {
        writing-mode: vertical-lr;
        text-orientation: mixed;
        font-size: 12px;
        color: #94a3b8;
        font-weight: 500;
        margin: 0;
      }

      #sidebar-right-assets {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      #sidebar-tabs {
        display: flex;
        padding: 8px 12px 0 12px;
        gap: 8px;
        border-bottom: 1px solid transparent;
      }
      .tab-btn {
        flex: 1;
        padding: 10px 4px;
        text-align: center;
        cursor: pointer;
        font-weight: 600;
        color: var(--text-sub);
        background: transparent;
        font-size: 13px;
        transition: all 0.2s;
        border-radius: 6px 6px 0 0;
        border-bottom: 2px solid transparent;
      }
      .tab-btn:hover {
        color: var(--text-main);
        background: #f8fafc;
      }
      .tab-btn.active {
        color: var(--accent-primary);
        border-bottom-color: var(--accent-primary);
        background: transparent;
      }
      .tab-btn[data-tab="bg"].active {
        color: var(--accent-secondary);
        border-bottom-color: var(--accent-secondary);
      }

      #asset-list {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        display: flex;
        flex-wrap: wrap;
        align-content: flex-start;
        gap: 12px;
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 transparent;
      }
      #asset-list::-webkit-scrollbar {
        width: 6px;
      }
      #asset-list::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 3px;
      }

      .panel-sticker {
        width: 88px;
        height: 88px;
        object-fit: contain;
        cursor: grab;
        padding: 5px;
        border-radius: 12px;
        border: 1px solid #f1f5f9;
        background: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.02);
        transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      .panel-sticker:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.08);
        border-color: #e2e8f0;
      }
      .panel-sticker:active {
        transform: scale(0.95);
      }

      /* --- Ë¥¥Á∫∏‰∏éÈÄâ‰∏≠Ê°Ü --- */
      .sticker-item {
        position: absolute;
        transform-origin: center center;
        cursor: grab;
        will-change: transform;
        transition: opacity 0.1s; /* ÂÖâÊïàÈÄèÊòéÂ∫¶ÂèòÂåñÊõ¥Âπ≥Êªë */
      }
      .sticker-item:active {
        cursor: grabbing;
      }
      .sticker-item img {
        display: block;
        width: 100%;
        height: 100%;
        pointer-events: none;
        filter: url(#sticker-border-effect);
      }
      .sticker-item.is-dragging {
        z-index: 99999 !important;
        cursor: grabbing;
        opacity: 0.6 !important;
      }

      #selection-host {
        position: absolute;
        top: 0;
        left: 0;
        width: 100px;
        height: 100px;
        pointer-events: none;
        display: none;
        z-index: 500;
        transform-origin: center center;
      }
      #selection-host .handle {
        pointer-events: auto;
      }

      .sticker-border {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 2px solid var(--accent-primary);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5);
      }

      .handle {
        position: absolute;
        background: #fff;
        border: none;
        z-index: 1001;
        pointer-events: auto;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: transform 0.1s;
      }
      .handle:hover {
        transform: scale(1.2);
      }
      .handle-rot {
        top: 0;
        left: 50%;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: crosshair;
        background: var(--accent-primary);
        border: 2px solid #fff;
      }
      .handle-scale {
        bottom: 0;
        right: 0;
        width: 16px;
        height: 16px;
        border-radius: 4px;
        cursor: nwse-resize;
        border: 2px solid var(--accent-primary);
      }

      /* --- Âä®ÊÄÅÂÖâÊ∫ê (CSS Âä®Áîª) --- */
      .light-container {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .light-blob {
        position: absolute;
        border-radius: 50%;
        mix-blend-mode: screen;
        filter: blur(8px);
        opacity: 0.7;
      }
      .light-blob.outer {
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle,
          var(--light-color, #ffaa00) 0%,
          transparent 70%
        );
        animation: blob-wobble 4s ease-in-out infinite;
      }
      .light-blob.inner {
        width: 60%;
        height: 60%;
        background: radial-gradient(
          circle,
          #fff 0%,
          var(--light-color, #ffaa00) 80%,
          transparent 100%
        );
        animation: blob-wobble 3s ease-in-out infinite reverse;
      }
      @keyframes blob-wobble {
        0%,
        100% {
          border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%;
          transform: scale(1);
        }
        50% {
          border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%;
          transform: scale(1.05);
        }
      }

      /* --- ÊÇ¨ÊµÆÊìç‰ΩúÊ†è --- */
      #floating-tools {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(30, 41, 59, 0.85);
        backdrop-filter: blur(12px);
        color: white;
        border-radius: 50px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
        z-index: 900;
        padding: 8px 20px;
        display: flex;
        gap: 15px;
        opacity: 0;
        pointer-events: none;
        transition: all 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        border: 1px solid rgba(255, 255, 255, 0.1);
        align-items: center;
      }
      #floating-tools.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
      }

      #floating-tools button {
        background: transparent;
        border: none;
        color: #f1f5f9;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 5px 10px;
        border-radius: 4px;
        transition: opacity 0.2s;
      }
      #floating-tools button:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      #floating-tools button:active {
        transform: scale(0.95);
      }

      /* È¢úËâ≤/‰∏çÈÄèÊòéÂ∫¶ÈÄâÊã©Âô® wrapper */
      .tool-control-wrapper {
        display: none;
        align-items: center;
        margin-left: 5px;
        gap: 8px;
      }
      .tool-control-wrapper.visible {
        display: flex;
      }
      
      input[type="color"] {
        -webkit-appearance: none;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        padding: 0;
        overflow: hidden;
        cursor: pointer;
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.2);
      }
      
      /* Â∞èÊªëÂùóÊ†∑Âºè */
      .mini-range {
        width: 60px !important;
        height: 4px;
      }
      .mini-range-label {
        font-size: 10px; 
        color: #ccc; 
        font-weight: bold;
      }

      .drag-ghost {
        position: fixed;
        z-index: 99999;
        pointer-events: none;
        opacity: 0.8;
        width: 100px;
        height: 100px;
        object-fit: contain;
        transform: translate(-50%, -50%);
      }
      #loading-toast {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        z-index: 9999;
        display: none;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="loading-toast">Ê≠£Âú®Âä†ËΩΩÂàùÂßãÂú∫ÊôØ...</div>
    <div id="top-bar">
      <button class="ui-btn mode-btn active" data-mode="deco">
        üß∏ Ë£ÖÈ•∞Ê®°Âºè
      </button>
      <button class="ui-btn mode-btn" data-mode="bg">üåÑ ËÉåÊôØÊ®°Âºè</button>
      <div style="width: 1px; background: #ddd; margin: 0 4px"></div>
      <button class="ui-btn" id="btn-undo" disabled title="Âø´Êç∑ÈîÆ: Ctrl+Z">‚Ü©</button>
      <button class="ui-btn" id="btn-redo" disabled title="Âø´Êç∑ÈîÆ: Ctrl+Y">‚Ü™</button>
      <div style="width: 1px; background: #ddd; margin: 0 4px"></div>
      <div class="ui-control-group">
        <label for="border-width">ËæπÊ°ÜÁ≤óÁªÜ</label>
        <input
          type="range"
          id="border-width"
          min="0"
          max="30"
          value="2"
          step="0.5"
        />
      </div>
      <div class="ui-control-group">
        <label for="border-opacity">ËæπÊ°Ü‰∏çÈÄèÊòéÂ∫¶</label>
        <input
          type="range"
          id="border-opacity"
          min="0"
          max="1"
          value="0.8"
          step="0.1"
        />
      </div>
      <div style="width: 1px; background: #ddd; margin: 0 4px"></div>
      <button class="ui-btn" id="btn-import">üìÅ ÂØºÂÖ• JSON</button>
      <button class="ui-btn primary" id="btn-export">üíæ ÂØºÂá∫ JSON</button>
      <button class="ui-btn" id="btn-reset-view">üìç ÈÄÇÈÖçËßÜÂõæ</button>
      <button class="ui-btn danger" id="btn-clear">üóëÔ∏è Ê∏ÖÁ©∫</button>
      
      <!-- ÈöêËóèÁöÑÊñá‰ª∂ËæìÂÖ•Ê°Ü -->
      <input type="file" id="file-input" style="display: none" accept=".json" />
    </div>

    <div id="viewport">
      <div id="world">
        <div id="layer-container-bg"></div>
        <div id="layer-container-deco"></div>
        <div id="selection-host">
          <div class="sticker-border"></div>
          <div class="handle handle-rot"></div>
          <div class="handle handle-scale"></div>
        </div>
      </div>
    </div>

    <div id="sidebar" class="mode-deco">
      <div id="sidebar-left-control">
        <div class="layer-label">È°∂Â±Ç</div>
        <div class="layer-slider-container">
          <input
            type="range"
            class="big-vertical-range"
            id="layer-slider"
            min="0"
            max="100"
            step="1"
            value="0"
            title="Âø´Êç∑ÈîÆ: ‚Üë / ‚Üì"
          />
        </div>
        <div class="layer-label">Â∫ïÂ±Ç</div>
      </div>
      <div id="sidebar-right-assets">
        <div id="sidebar-tabs">
          <div class="tab-btn active" data-tab="static">Ë£ÖÈ•∞Ë¥¥Á∫∏</div>
          <div class="tab-btn" data-tab="dynamic">Âä®ÊÄÅË£ÖÈ•∞</div>
          <div class="tab-btn" data-tab="bg" style="color: var(--accent-bg)">
            ËÉåÊôØÁªÑ‰ª∂
          </div>
        </div>
        <div id="asset-list"></div>
      </div>
    </div>

    <div id="floating-tools">
      <button data-action="flip">‚áÑ ÁøªËΩ¨</button>
      <div style="width: 1px; background: #555; height: 16px"></div>
      <button data-action="delete" style="color: #ff8888" title="Âø´Êç∑ÈîÆ: Delete">üóëÔ∏è Âà†Èô§</button>

      <!-- ÂÖâÊïà‰∏ìÂ±ûÊéß‰ª∂ (È¢úËâ≤ + ‰∏çÈÄèÊòéÂ∫¶) -->
      <div class="tool-control-wrapper" id="tool-light-controls">
        <div style="width: 1px; background: #555; height: 16px; margin: 0 5px"></div>
        <input
          type="color"
          id="tool-light-color"
          value="#ffaa00"
          title="ÂÖâÊïàÈ¢úËâ≤"
        />
        <div style="display:flex; flex-direction:column; align-items:center;">
          <input type="range" id="tool-light-opacity" min="0.1" max="1" step="0.05" value="1" class="mini-range" title="ÂÖâÊïàÂº∫Â∫¶">
        </div>
      </div>
    </div>

    <svg width="0" height="0" style="position: absolute; z-index: -1">
      <defs>
        <filter id="sticker-border-effect">
          <feMorphology
            in="SourceAlpha"
            result="dilated"
            operator="dilate"
            radius="2"
          ></feMorphology>
          <feFlood
            id="sticker-border-color"
            flood-color="white"
            flood-opacity="0.8"
            result="color"
          />
          <feComposite in="color" in2="dilated" operator="in" result="border" />
          <feMerge>
            <feMergeNode in="border" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
    </svg>

    <script>
      const CONFIG = {
        rootPath: "assets",
        defaultTab: "static",
        dynamicPath: "dynamic",
        bgPath: "BG",
        importScale: 1,
        initialZoom: 1.0,
        counts: { static: 51, dynamic: 11, bg: 8 },
        defaultAnimFPS: 12,
        defaultSceneFile: "assets/default.json",
      };

      const STATE = {
        viewport: { x: 0, y: 0, scale: 1 },
        isPanning: false,
        lastMouse: { x: 0, y: 0 },
        activeSticker: null,
        activeTab: CONFIG.defaultTab,
        editMode: "deco",
        animatingStickers: [],
        borderWidth: 2,
        borderOpacity: 0.8,
        spacePressed: false // Êñ∞Â¢ûÔºöÁ©∫Ê†ºÈîÆÁä∂ÊÄÅ
      };

      const DOM = {
        viewport: document.getElementById("viewport"),
        world: document.getElementById("world"),
        layerBg: document.getElementById("layer-container-bg"),
        layerDeco: document.getElementById("layer-container-deco"),
        sidebar: document.getElementById("sidebar"),
        panel: document.getElementById("asset-list"),
        toolbar: document.getElementById("floating-tools"),
        // ÂÖâÊïàÊéß‰ª∂ÁªÑ
        lightControls: document.getElementById("tool-light-controls"),
        lightColorInput: document.getElementById("tool-light-color"),
        lightOpacityInput: document.getElementById("tool-light-opacity"),
        
        layerSlider: document.getElementById("layer-slider"),
        tabs: document.querySelectorAll(".tab-btn"),
        modeBtns: document.querySelectorAll(".mode-btn"),
        toast: document.getElementById("loading-toast"),
        selectionHost: document.getElementById("selection-host"),
        borderWidthSlider: document.getElementById("border-width"),
        borderOpacitySlider: document.getElementById("border-opacity"),
        fileInput: document.getElementById("file-input"), // Êñ∞Â¢û
        feMorphology: document.querySelector(
          "#sticker-border-effect feMorphology",
        ),
        feFlood: document.querySelector("#sticker-border-color"),
      };

      const hitTestCanvas = document.createElement("canvas");
      hitTestCanvas.width = 1;
      hitTestCanvas.height = 1;
      const hitTestCtx = hitTestCanvas.getContext("2d", {
        willReadFrequently: true,
      });
      hitTestCtx.imageSmoothingEnabled = false;

      function getFramePath(folder, index) {
        return `${folder}/frames_${String(index + 1).padStart(3, "0")}.png`;
      }

      function updateStickerBorderStyle() {
        const width = DOM.borderWidthSlider.value;
        const opacity = DOM.borderOpacitySlider.value;
        const hasBorder = parseFloat(width) > 0;
        document.querySelectorAll(".sticker-item img").forEach((img) => {
          img.style.filter = hasBorder ? "url(#sticker-border-effect)" : "none";
        });
        if (hasBorder) {
          DOM.feMorphology.setAttribute("radius", width);
          DOM.feFlood.setAttribute("flood-opacity", opacity);
        }
      }

      function init() {
        setupViewportEvents();
        setupPanelDragLogic();
        setupGlobalInteraction();
        loadSidebarContent();
        requestAnimationFrame(animationLoop);
        switchMode("deco");
        loadDefaultScene();

        DOM.borderWidthSlider.value = STATE.borderWidth;
        DOM.borderOpacitySlider.value = STATE.borderOpacity;
        DOM.borderWidthSlider.addEventListener(
          "input",
          updateStickerBorderStyle,
        );
        DOM.borderOpacitySlider.addEventListener(
          "input",
          updateStickerBorderStyle,
        );

        // ÁõëÂê¨ÂÖâÊ∫êÈ¢úËâ≤
        DOM.lightColorInput.addEventListener("input", (e) => {
          if (
            STATE.activeSticker &&
            STATE.activeSticker.dataset.isLight === "true"
          ) {
            const color = e.target.value;
            STATE.activeSticker.style.setProperty("--light-color", color);
            STATE.activeSticker.dataset.lightColor = color;
          }
        });
        DOM.lightColorInput.addEventListener("change", () => HistoryManager.save());

        // ÁõëÂê¨ÂÖâÊ∫ê‰∏çÈÄèÊòéÂ∫¶ (Êñ∞Â¢û)
        DOM.lightOpacityInput.addEventListener("input", (e) => {
           if (STATE.activeSticker && STATE.activeSticker.dataset.isLight === "true") {
             const opacity = e.target.value;
             STATE.activeSticker.style.opacity = opacity;
             STATE.activeSticker.dataset.opacity = opacity;
           }
        });
        DOM.lightOpacityInput.addEventListener("change", () => HistoryManager.save());

        setupKeyboardShortcuts();
        updateStickerBorderStyle();
      }

      // Êñ∞Â¢ûÔºöÈîÆÁõòÂø´Êç∑ÈîÆ
      function setupKeyboardShortcuts() {
        window.addEventListener('keydown', (e) => {
          // Á©∫Ê†ºÈîÆÁä∂ÊÄÅ
          if (e.code === 'Space' && !e.repeat) {
            STATE.spacePressed = true;
            document.body.classList.add('space-pressed');
            // Â¶ÇÊûúÊ≠£Âú®ÊãñÂä®Ë¥¥Á∫∏Ôºå‰∏çÂ§ÑÁêÜ
            if (!document.querySelector('.is-dragging')) {
               DOM.viewport.style.cursor = "grab";
            }
          }

          // Â¶ÇÊûúÂú®ËæìÂÖ•Ê°ÜÂÜÖÔºå‰∏çËß¶ÂèëÂø´Êç∑ÈîÆ
          if (e.target.tagName === 'INPUT') return;

          // Êí§ÈîÄ/ÈáçÂÅö
          if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) {
            e.preventDefault();
            if (e.shiftKey) {
              HistoryManager.redo();
            } else {
              HistoryManager.undo();
            }
          }
          if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y')) {
            e.preventDefault();
            HistoryManager.redo();
          }

          // Âà†Èô§
          if (e.key === 'Delete' || e.key === 'Backspace') {
            if (STATE.activeSticker) {
              deleteSticker(STATE.activeSticker);
              HistoryManager.save();
            }
          }

          // Â±ÇÁ∫ßË∞ÉÊï¥ (‰∏ä‰∏ãÈîÆ)
          if (STATE.activeSticker) {
            if (e.key === 'ArrowUp') {
              e.preventDefault();
              moveLayer(STATE.activeSticker, 1);
            } else if (e.key === 'ArrowDown') {
              e.preventDefault();
              moveLayer(STATE.activeSticker, -1);
            }
          }
        });

        window.addEventListener('keyup', (e) => {
          if (e.code === 'Space') {
            STATE.spacePressed = false;
            document.body.classList.remove('space-pressed');
            DOM.viewport.style.cursor = "default";
          }
        });
      }

      // ËæÖÂä©ÂáΩÊï∞ÔºöÁßªÂä®ÂõæÂ±Ç
      function moveLayer(el, direction) {
        const parent = el.parentNode;
        const siblings = Array.from(parent.children);
        const index = siblings.indexOf(el);
        const newIndex = index + direction;

        if (newIndex >= 0 && newIndex < siblings.length) {
          if (direction > 0) {
             parent.insertBefore(el, siblings[newIndex].nextSibling);
          } else {
             parent.insertBefore(el, siblings[newIndex]);
          }
          updateLayerSlider(el);
          HistoryManager.save();
        }
      }

      function isPixelHit(el, clientX, clientY) {
        if (el.dataset.isLight === "true") return true;

        const img = el.querySelector("img");
        if (!img || !img.complete || img.naturalWidth === 0) return false;

        const worldPoint = screenToWorld(clientX, clientY);
        const x = parseFloat(el.style.left),
          y = parseFloat(el.style.top);
        const w = parseFloat(el.style.width),
          h = parseFloat(el.style.height);
        const centerX = x + w / 2,
          centerY = y + h / 2;
        const r = parseFloat(el.dataset.r || 0),
          s = parseFloat(el.dataset.s || 1),
          f = parseFloat(el.dataset.f || 1);

        const dx = worldPoint.x - centerX,
          dy = worldPoint.y - centerY;
        const rad = -r * (Math.PI / 180);
        const rotatedX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const rotatedY = dx * Math.sin(rad) + dy * Math.cos(rad);
        const scaledX = rotatedX / s,
          scaledY = rotatedY / s;
        const flippedX = scaledX * f;
        const localX = flippedX + w / 2,
          localY = scaledY + h / 2;

        if (localX < 0 || localX > w || localY < 0 || localY > h) return false;

        try {
          const naturalX = Math.floor(localX * (img.naturalWidth / w));
          const naturalY = Math.floor(localY * (img.naturalHeight / h));
          hitTestCtx.clearRect(0, 0, 1, 1);
          hitTestCtx.drawImage(img, naturalX, naturalY, 1, 1, 0, 0, 1, 1);
          return hitTestCtx.getImageData(0, 0, 1, 1).data[3] > 10;
        } catch (e) {
          return true;
        }
      }

      async function loadDefaultScene() {
        DOM.toast.style.display = "block";
        try {
          const response = await fetch(CONFIG.defaultSceneFile);
          if (!response.ok) throw new Error("Êó†ÈªòËÆ§Âú∫ÊôØ");
          const data = await response.json();
          await loadSceneData(data); // ÊäΩÂèñÂÖ¨ÂÖ±Âä†ËΩΩÈÄªËæë
        } catch (e) {
          centerViewInitially();
        } finally {
          DOM.toast.style.display = "none";
        }
      }
      
      // Ê†∏ÂøÉÂä†ËΩΩÈÄªËæë (Áî®‰∫éÈªòËÆ§Âú∫ÊôØÂíåÂØºÂÖ•)
      async function loadSceneData(data) {
          if (data.layers) {
            DOM.layerBg.innerHTML = "";
            DOM.layerDeco.innerHTML = "";
            STATE.animatingStickers = [];

            if (data.layers.bg) {
              const bgPromises = data.layers.bg.map((item) => {
                item.type = "bg";
                return createSticker(item, 0, 0, false, false);
              });
              const bgElements = await Promise.all(bgPromises);
              bgElements.forEach((el) => {
                if (el) DOM.layerBg.appendChild(el);
              });
            }

            if (data.layers.deco) {
              const decoPromises = data.layers.deco.map((item) => {
                item.type = "deco";
                return createSticker(item, 0, 0, false, false);
              });
              const decoElements = await Promise.all(decoPromises);
              decoElements.forEach((el) => {
                if (el) DOM.layerDeco.appendChild(el);
              });
            }
            
            // ÊÅ¢Â§çËßÜÂõæ
            if(data.viewport) {
                STATE.viewport = data.viewport;
                updateWorldTransform();
            } else {
                fitViewToContent();
            }
          }
      }

      function centerViewInitially() {
        const vpW = DOM.viewport.clientWidth,
          vpH = DOM.viewport.clientHeight;
        STATE.viewport.scale = CONFIG.initialZoom;
        STATE.viewport.x = vpW / 2;
        STATE.viewport.y = vpH / 2;
        updateWorldTransform();
      }

      function switchMode(mode) {
        deselectAll();
        STATE.editMode = mode;
        DOM.modeBtns.forEach((btn) =>
          btn.classList.toggle("active", btn.dataset.mode === mode),
        );
        DOM.sidebar.className = mode === "bg" ? "mode-bg" : "mode-deco";
        DOM.layerDeco.classList.toggle("layer-locked", mode === "bg");
        DOM.layerBg.classList.toggle("layer-locked", mode !== "bg");
        activateTab(mode === "bg" ? "bg" : "static");
      }

      function activateTab(tabName) {
        STATE.activeTab = tabName;
        DOM.tabs.forEach((t) =>
          t.classList.toggle("active", t.dataset.tab === tabName),
        );
        loadSidebarContent();
      }

      function loadSidebarContent() {
        DOM.panel.innerHTML = "";
        const tab = STATE.activeTab;

        if (tab === "static") {
          loadImages(
            `${CONFIG.rootPath}/sticker_`,
            CONFIG.counts.static,
            false,
            "deco",
          );
        } else if (tab === "bg") {
          loadImages(
            `${CONFIG.rootPath}/${CONFIG.bgPath}/bg_`,
            CONFIG.counts.bg,
            false,
            "bg",
          );
        } else if (tab === "dynamic") {
          const lightIconSrc =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZhYTAwIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNSIvPjxsaW5lIHgxPSIxMiIgeTE9IjEiIHgyPSIxMiIgeTI9IjMiLz48bGluZSB4MT0iMTIiIHkxPSIyMSIgeDI9IjEyIiB5Mj0iMjMiLz48bGluZSB4MT0iNC4yMiIgeTE9IjQuMjIiIHgyPSI1LjY0IiB5Mj0iNS42NCIvPjxsaW5lIHgxPSIxOC4zNiIgeTE9IjE4LjM2IiB4Mj0iMTkuNzgiIHkyPSIxOS43OCIvPjxsaW5lIHgxPSIxIiB5MT0iMTIiIHgyPSIzIiB5Mj0iMTIiLz48bGluZSB4MT0iMjEiIHkxPSIxMiIgeDI9IjIzIiB5Mj0iMTIiLz48bGluZSB4MT0iNC4yMiIgeTE9IjE5Ljc4IiB4Mj0iNS42NCIgeTI9IjE4LjM2Ii8+PGxpbmUgeDE9IjE4LjM2IiB5MT0iNS42NCIgeDI9IjE5Ljc4IiB5Mj0iNC4yMiIvPjwvc3ZnPg==";

          const div = document.createElement("div");
          div.className = "panel-sticker";
          div.style.display = "flex";
          div.style.alignItems = "center";
          div.style.justifyContent = "center";
          div.innerHTML = `<img src="${lightIconSrc}" style="width:80%;height:80%;pointer-events:none;">`;

          Object.assign(div.dataset, {
            src: lightIconSrc,
            isLight: "true",
            type: "deco",
          });
          DOM.panel.appendChild(div);

          for (let i = 1; i < CONFIG.counts.dynamic; i++) {
            const folder = `${CONFIG.rootPath}/${CONFIG.dynamicPath}/anim_${i}`;
            createPanelThumb(getFramePath(folder, 0), true, {
              type: "deco",
              folder,
              total: 30,
            });
          }
        }
      }

      function loadImages(prefix, count, isDynamic, type) {
        for (let i = 0; i < count; i++)
          createPanelThumb(`${prefix}${i}.png`, isDynamic, { type });
      }

      function createPanelThumb(src, isDynamic, meta) {
        const img = document.createElement("img");
        img.className = "panel-sticker";
        img.src = src;
        img.draggable = false;
        Object.assign(img.dataset, {
          src,
          isDynamic,
          type: meta.type,
          animFolder: meta.folder,
          animTotal: meta.total,
        });
        img.onerror = () => {
          img.src = `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZWVlIi8+PC9zdmc+`;
        };
        DOM.panel.appendChild(img);
      }

      function createSticker(
        data,
        cx,
        cy,
        saveHistory = true,
        autoAppend = true,
      ) {
        return new Promise((resolve) => {
          const isFromJson = data.w !== undefined;
          const isLight = data.isLight === "true" || data.isLight === true;

          const finalizeSticker = (w, h, src) => {
            const finalW = isFromJson ? data.w : w * CONFIG.importScale;
            const finalH = isFromJson ? data.h : h * CONFIG.importScale;
            const div = document.createElement("div");
            div.className = "sticker-item";
            div.style.cssText = `width:${finalW}px; height:${finalH}px; left:${isFromJson ? data.x : cx - finalW / 2}px; top:${isFromJson ? data.y : cy - finalH / 2}px;`;

            Object.assign(div.dataset, {
              type: data.type || (isFromJson ? "deco" : STATE.editMode),
              r: data.r || 0,
              s: data.s || 1,
              f: data.f || 1,
              originSrc: src,
              isDynamic: data.isDynamic,
              isLight: isLight,
              lightColor: data.lightColor || "#ffaa00",
              opacity: data.opacity || 1, // ÊÅ¢Â§ç‰∏çÈÄèÊòéÂ∫¶
              animFolder: data.animFolder || data.folder,
              animTotal: data.animTotal || data.total,
            });
            
            // Â∫îÁî®‰øùÂ≠òÁöÑ opacity
            if(data.opacity) div.style.opacity = data.opacity;

            if (isLight) {
              div.style.setProperty(
                "--light-color",
                data.lightColor || "#ffaa00",
              );

              const durOut = 3 + Math.random() * 2;
              const delOut = -(Math.random() * 5);
              const durIn = 2 + Math.random() * 2;
              const delIn = -(Math.random() * 5);

              div.innerHTML = `
                  <div class="light-container">
                    <div class="light-blob outer" style="animation-duration: ${durOut}s; animation-delay: ${delOut}s;"></div>
                    <div class="light-blob inner" style="animation-duration: ${durIn}s; animation-delay: ${delIn}s;"></div>
                  </div>
                  <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" style="opacity:0; width:100%; height:100%; position:absolute;">
                `;
            } else {
              div.innerHTML = `<img src="${src}" draggable="false" crossorigin="anonymous">`;
            }

            updateStickerBorderStyle();

            if (data.isDynamic === "true" || data.isDynamic === true) {
              registerAnimation(
                div,
                div.dataset.animFolder,
                div.dataset.animTotal,
              );
            }

            updateStickerTransform(div);

            if (autoAppend) {
              const targetLayer =
                div.dataset.type === "bg" ? DOM.layerBg : DOM.layerDeco;
              targetLayer.appendChild(div);
              if (saveHistory) {
                selectSticker(div);
                HistoryManager.save();
              }
            }
            resolve(div);
          };

          if (isLight) {
            finalizeSticker(200, 200, data.src);
          } else {
            const tempImg = new Image();
            tempImg.crossOrigin = "Anonymous";
            tempImg.src = data.src;
            tempImg.onload = () =>
              finalizeSticker(
                tempImg.naturalWidth || 200,
                tempImg.naturalHeight || 200,
                data.src,
              );
            tempImg.onerror = () => resolve(null);
          }
        });
      }

      function syncSelectionHost(sticker) {
        if (!sticker) {
          DOM.selectionHost.style.display = "none";
          return;
        }
        DOM.selectionHost.style.display = "block";
        DOM.selectionHost.style.left = sticker.style.left;
        DOM.selectionHost.style.top = sticker.style.top;
        DOM.selectionHost.style.width = sticker.style.width;
        DOM.selectionHost.style.height = sticker.style.height;
        DOM.selectionHost.style.transform = sticker.style.transform;

        const type = sticker.dataset.type;
        const borderColor =
          type === "bg" ? "var(--accent-secondary)" : "var(--accent-primary)";
        DOM.selectionHost.querySelector(".sticker-border").style.borderColor =
          borderColor;
        DOM.selectionHost
          .querySelectorAll(".handle")
          .forEach((h) => (h.style.borderColor = borderColor));
        updateHandleVisuals(sticker, DOM.selectionHost);
      }

      function updateHandleVisuals(el, uiContainer) {
        if (!el || !uiContainer) return;
        const s = parseFloat(el.dataset.s) || 1,
          viewportS = STATE.viewport.scale;
        const invScale = 1 / (s * viewportS);
        const rotHandle = uiContainer.querySelector(".handle-rot");
        const scaleHandle = uiContainer.querySelector(".handle-scale");
        const border = uiContainer.querySelector(".sticker-border");
        if (!rotHandle || !scaleHandle || !border) return;

        rotHandle.style.transform = `translate(-50%, -50%) scale(${invScale})`;
        scaleHandle.style.transform = `translate(50%, 50%) scale(${invScale})`;
        const offset = 25 * invScale;
        rotHandle.style.top = `-${offset}px`;
        scaleHandle.style.bottom = `-${offset / 2}px`;
        scaleHandle.style.right = `-${offset / 2}px`;
        border.style.borderWidth = `${2 * invScale}px`;
        border.style.borderRadius = `${8 * invScale}px`;
      }

      function fitViewToContent() {
        const allStickers = document.querySelectorAll(".sticker-item");
        if (allStickers.length === 0) {
          centerViewInitially();
          return;
        }
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        allStickers.forEach((el) => {
          const l = parseFloat(el.style.left),
            t = parseFloat(el.style.top);
          const w = parseFloat(el.style.width),
            h = parseFloat(el.style.height);
          const s = parseFloat(el.dataset.s);
          const cx = l + w / 2,
            cy = t + h / 2;
          const sw = w * s,
            sh = h * s;
          const realL = cx - sw / 2,
            realT = cy - sh / 2,
            realR = cx + sw / 2,
            realB = cy + sh / 2;
          if (realL < minX) minX = realL;
          if (realT < minY) minY = realT;
          if (realR > maxX) maxX = realR;
          if (realB > maxY) maxY = realB;
        });
        const contentW = maxX - minX,
          contentH = maxY - minY;
        const padding = Math.max(contentW, contentH) * 0.2;
        const finalW = contentW + padding * 2,
          finalH = contentH + padding * 2;
        const centerX = minX + contentW / 2,
          centerY = minY + contentH / 2;
        const vpW = DOM.viewport.clientWidth,
          vpH = DOM.viewport.clientHeight;
        let scale = Math.min(vpW / finalW, vpH / finalH);
        scale = Math.max(0.1, Math.min(scale, 3));
        STATE.viewport.scale = scale;
        STATE.viewport.x = vpW / 2 - centerX * scale;
        STATE.viewport.y = vpH / 2 - centerY * scale;
        updateWorldTransform();
      }

      function setupViewportEvents() {
        DOM.viewport.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(
              0.1,
              Math.min(STATE.viewport.scale * scaleFactor, 5),
            );
            const rect = DOM.viewport.getBoundingClientRect();
            const mx = e.clientX - rect.left,
              my = e.clientY - rect.top;
            STATE.viewport.x =
              mx - (mx - STATE.viewport.x) * (newScale / STATE.viewport.scale);
            STATE.viewport.y =
              my - (my - STATE.viewport.y) * (newScale / STATE.viewport.scale);
            STATE.viewport.scale = newScale;
            updateWorldTransform();
          },
          { passive: false },
        );

        const handleGlobalDown = (e) => {
          if (e.target.closest(".handle, #floating-tools, #sidebar, #top-bar"))
            return;
          
          // ‰øÆÊîπÔºö‰∏≠ÈîÆ(button 1) Êàñ Á©∫Ê†ºÈîÆÊåâ‰∏ã -> Âº∫Âà∂Âπ≥Áßª
          const isMiddleClick = e.button === 1;
          if (isMiddleClick || STATE.spacePressed) {
             startPan(e);
             return;
          }

          const { x, y } = getEventPos(e);
          const elements = document.elementsFromPoint(x, y);
          let targetSticker = null;
          for (const el of elements) {
            if (
              el.classList.contains("sticker-item") &&
              el.dataset.type === STATE.editMode &&
              isPixelHit(el, x, y)
            ) {
              targetSticker = el;
              break;
            }
          }
          if (targetSticker) triggerStickerDrag(e, targetSticker);
          else startPan(e);
        };
        DOM.viewport.addEventListener("mousedown", handleGlobalDown);
        DOM.viewport.addEventListener("touchstart", handleGlobalDown, {
          passive: false,
        });
      }

      function triggerStickerDrag(e, el) {
        e.stopPropagation();
        e.preventDefault();
        if (STATE.activeSticker !== el) {
          HistoryManager.save();
          selectSticker(el);
        }
        el.classList.add("is-dragging");
        const { x: startX, y: startY } = getEventPos(e);
        const startLeft = parseFloat(el.style.left),
          startTop = parseFloat(el.style.top);

        const onMove = (me) => {
          const { x: currX, y: currY } = getEventPos(me);
          el.style.left =
            startLeft + (currX - startX) / STATE.viewport.scale + "px";
          el.style.top =
            startTop + (currY - startY) / STATE.viewport.scale + "px";
          syncSelectionHost(el);
          DOM.sidebar.classList.toggle(
            "drag-over",
            currX > DOM.sidebar.getBoundingClientRect().left,
          );
        };
        const onUp = (me) => {
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("touchmove", onMove);
          document.removeEventListener("mouseup", onUp);
          document.removeEventListener("touchend", onUp);
          el.classList.remove("is-dragging");
          if (getEventPos(me).x > DOM.sidebar.getBoundingClientRect().left) {
            deleteSticker(el);
            HistoryManager.save();
          } else {
            HistoryManager.save();
          }
          DOM.sidebar.classList.remove("drag-over");
        };
        document.addEventListener("mousemove", onMove);
        document.addEventListener("touchmove", onMove, { passive: false });
        document.addEventListener("mouseup", onUp);
        document.addEventListener("touchend", onUp);
      }

      function startPan(e) {
        STATE.isPanning = true;
        STATE.lastMouse = getEventPos(e);
        DOM.viewport.style.cursor = "grabbing";
        // Âπ≥ÁßªÊó∂‰∏çÂèñÊ∂àÈÄâ‰∏≠ÔºåÈô§ÈùûÊòØÁÇπÂáªÁ©∫ÁôΩÂ§Ñ
        // deselectAll(); 
        const movePan = (me) => {
          if (!STATE.isPanning) return;
          me.preventDefault();
          const pos = getEventPos(me);
          STATE.viewport.x += pos.x - STATE.lastMouse.x;
          STATE.viewport.y += pos.y - STATE.lastMouse.y;
          STATE.lastMouse = pos;
          updateWorldTransform();
        };
        const endPan = () => {
          STATE.isPanning = false;
          // ÊÅ¢Â§çÈº†Ê†áÊ†∑Âºè
          DOM.viewport.style.cursor = STATE.spacePressed ? "grab" : "default";
          document.removeEventListener("mousemove", movePan);
          document.removeEventListener("touchmove", movePan);
          document.removeEventListener("mouseup", endPan);
          document.removeEventListener("touchend", endPan);
        };
        document.addEventListener("mousemove", movePan);
        document.addEventListener("touchmove", movePan, { passive: false });
        document.addEventListener("mouseup", endPan);
        document.addEventListener("touchend", endPan);
      }

      function handleTransform(e, el, type) {
        e.stopPropagation();
        e.preventDefault();
        HistoryManager.save();
        const w = parseFloat(el.style.width),
          h = parseFloat(el.style.height);
        const centerX = parseFloat(el.style.left) + w / 2,
          centerY = parseFloat(el.style.top) + h / 2;
        const startWorldPos = screenToWorld(getEventPos(e).x, getEventPos(e).y);
        const initR = parseFloat(el.dataset.r),
          initS = parseFloat(el.dataset.s);
        const startAng = Math.atan2(
          startWorldPos.y - centerY,
          startWorldPos.x - centerX,
        );
        const initialDist = Math.sqrt(
          Math.pow(startWorldPos.x - centerX, 2) +
            Math.pow(startWorldPos.y - centerY, 2),
        );

        const onMove = (me) => {
          const currentWorldPos = screenToWorld(
            getEventPos(me).x,
            getEventPos(me).y,
          );
          if (type === "rotate") {
            const curAng = Math.atan2(
              currentWorldPos.y - centerY,
              currentWorldPos.x - centerX,
            );
            el.dataset.r = initR + ((curAng - startAng) * 180) / Math.PI;
          } else if (type === "scale") {
            const currentDist = Math.sqrt(
              Math.pow(currentWorldPos.x - centerX, 2) +
                Math.pow(currentWorldPos.y - centerY, 2),
            );
            if (initialDist > 1)
              el.dataset.s = Math.max(0.1, initS * (currentDist / initialDist));
          }
          updateStickerTransform(el);
        };
        const onUp = () => {
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("touchmove", onMove);
          document.removeEventListener("mouseup", onUp);
          document.removeEventListener("touchend", onUp);
          HistoryManager.save();
        };
        document.addEventListener("mousemove", onMove);
        document.addEventListener("touchmove", onMove, { passive: false });
        document.addEventListener("mouseup", onUp);
        document.addEventListener("touchend", onUp);
      }

      function selectSticker(el) {
        if (STATE.activeSticker) STATE.activeSticker.classList.remove("active");
        STATE.activeSticker = el;
        el.classList.add("active");
        updateLayerSlider(el);
        DOM.toolbar.classList.add("visible");

        // Ê£ÄÊü•ÂÖâÊ∫êÁ±ªÂûãÂπ∂ÊòæÁ§∫È¢úËâ≤ÈÄâÊã©Âô®
        const isLight = el.dataset.isLight === "true";
        if (isLight) {
          DOM.lightControls.classList.add("visible");
          DOM.lightColorInput.value = el.dataset.lightColor || "#ffaa00";
          DOM.lightOpacityInput.value = el.dataset.opacity || "1";
        } else {
          DOM.lightControls.classList.remove("visible");
        }

        syncSelectionHost(el);
        const rotHandle = DOM.selectionHost.querySelector(".handle-rot");
        const scaleHandle = DOM.selectionHost.querySelector(".handle-scale");
        const newRot = rotHandle.cloneNode(true);
        rotHandle.parentNode.replaceChild(newRot, rotHandle);
        newRot.addEventListener("mousedown", (e) =>
          handleTransform(e, el, "rotate"),
        );
        newRot.addEventListener(
          "touchstart",
          (e) => handleTransform(e, el, "rotate"),
          { passive: false },
        );
        const newScale = scaleHandle.cloneNode(true);
        scaleHandle.parentNode.replaceChild(newScale, scaleHandle);
        newScale.addEventListener("mousedown", (e) =>
          handleTransform(e, el, "scale"),
        );
        newScale.addEventListener(
          "touchstart",
          (e) => handleTransform(e, el, "scale"),
          { passive: false },
        );
      }

      function deselectAll() {
        if (STATE.activeSticker) STATE.activeSticker.classList.remove("active");
        STATE.activeSticker = null;
        DOM.toolbar.classList.remove("visible");
        DOM.lightControls.classList.remove("visible");
        syncSelectionHost(null);
      }

      function deleteSticker(el) {
        if (!el) return;
        if (el.dataset.isDynamic === "true")
          STATE.animatingStickers = STATE.animatingStickers.filter(
            (a) => a.element !== el.querySelector("img"),
          );
        el.remove();
        deselectAll();
      }

      function updateLayerSlider(el) {
        const parent = el.parentNode,
          children = Array.from(parent.children),
          index = children.indexOf(el);
        DOM.layerSlider.max = children.length - 1;
        DOM.layerSlider.value = index;
      }
      DOM.layerSlider.addEventListener("input", (e) => {
        if (!STATE.activeSticker) return;
        const val = parseInt(e.target.value),
          el = STATE.activeSticker,
          parent = el.parentNode;
        const siblings = Array.from(parent.children);
        if (val >= siblings.length - 1) parent.appendChild(el);
        else {
          const ref = siblings[val];
          if (ref !== el)
            parent.insertBefore(
              el,
              val > siblings.indexOf(el) ? ref.nextSibling : ref,
            );
        }
      });
      DOM.layerSlider.addEventListener("change", () => HistoryManager.save());

      function setupPanelDragLogic() {
        let ghost = null,
          dragInfo = null;
        const onStart = (e) => {
          const target = e.target.closest(".panel-sticker");
          if (!target) return;
          e.preventDefault();
          dragInfo = { ...target.dataset };
          ghost = target.cloneNode(true);
          ghost.className = "drag-ghost";
          document.body.appendChild(ghost);
          moveGhost(e);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("touchmove", onMove, { passive: false });
          document.addEventListener("mouseup", onEnd);
          document.addEventListener("touchend", onEnd);
        };
        const moveGhost = (e) => {
          const { x, y } = getEventPos(e);
          ghost.style.left = x + "px";
          ghost.style.top = y + "px";
        };
        const onMove = (e) => {
          e.preventDefault();
          moveGhost(e);
        };
        const onEnd = (e) => {
          const { x, y } = getEventPos(e);
          const rect = DOM.viewport.getBoundingClientRect();
          if (
            x > rect.left &&
            x < rect.right &&
            y > rect.top &&
            y < rect.bottom
          ) {
            createSticker(
              dragInfo,
              screenToWorld(x, y).x,
              screenToWorld(x, y).y,
            );
          }
          ghost.remove();
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("touchmove", onMove);
          document.removeEventListener("mouseup", onEnd);
          document.removeEventListener("touchend", onEnd);
        };
        DOM.panel.addEventListener("mousedown", onStart);
        DOM.panel.addEventListener("touchstart", onStart, { passive: false });
        DOM.tabs.forEach((btn) =>
          btn.addEventListener("click", () => {
            if (btn.dataset.tab === "bg" && STATE.editMode !== "bg")
              switchMode("bg");
            else if (btn.dataset.tab !== "bg" && STATE.editMode === "bg")
              switchMode("deco");
            activateTab(btn.dataset.tab);
          }),
        );
      }

      function exportSceneToJson() {
        const extract = (el) => ({
          src: el.dataset.originSrc,
          type: el.dataset.type,
          x: parseFloat(el.style.left),
          y: parseFloat(el.style.top),
          w: parseFloat(el.style.width),
          h: parseFloat(el.style.height),
          r: parseFloat(el.dataset.r),
          s: parseFloat(el.dataset.s),
          f: parseFloat(el.dataset.f),
          isDynamic: el.dataset.isDynamic === "true",
          isLight: el.dataset.isLight === "true",
          lightColor: el.dataset.lightColor,
          opacity: el.dataset.opacity, // ÂØºÂá∫‰∏çÈÄèÊòéÂ∫¶
          animFolder: el.dataset.animFolder,
          animTotal: el.dataset.animTotal,
        });
        const exportData = {
          version: "1.1",
          timestamp: new Date().toISOString(),
          viewport: STATE.viewport,
          layers: {
            bg: Array.from(DOM.layerBg.children).map(extract),
            deco: Array.from(DOM.layerDeco.children).map(extract),
          },
        };
        const blob = new Blob([JSON.stringify(exportData, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `scene_export_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function setupGlobalInteraction() {
        DOM.modeBtns.forEach((btn) =>
          btn.addEventListener("click", () => switchMode(btn.dataset.mode)),
        );
        document
          .getElementById("btn-reset-view")
          .addEventListener("click", fitViewToContent);
        document
          .getElementById("btn-export")
          .addEventListener("click", exportSceneToJson);
          
        // ÂØºÂÖ•ÂäüËÉΩ
        document.getElementById("btn-import").addEventListener("click", () => {
           DOM.fileInput.click();
        });
        
        DOM.fileInput.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    const json = JSON.parse(ev.target.result);
                    DOM.toast.style.display = "block";
                    DOM.toast.textContent = "Ê≠£Âú®ÂØºÂÖ•...";
                    await loadSceneData(json);
                } catch(err) {
                    alert("Êñá‰ª∂Ê†ºÂºèÈîôËØØ");
                    console.error(err);
                } finally {
                    DOM.toast.style.display = "none";
                    DOM.fileInput.value = ""; // ÈáçÁΩÆ
                }
            };
            reader.readAsText(file);
        });

        // Ê∏ÖÁ©∫Á°ÆËÆ§
        document.getElementById("btn-clear").addEventListener("click", () => {
          if (!confirm("Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÁîªÂ∏ÉÂêóÔºüÊ≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄ„ÄÇ")) return;
          
          HistoryManager.save();
          const container =
            STATE.editMode === "bg" ? DOM.layerBg : DOM.layerDeco;
          container.innerHTML = "";
          STATE.animatingStickers = STATE.animatingStickers.filter(
            (a) => !container.contains(a.element.parentElement),
          );
          deselectAll();
          HistoryManager.save();
        });

        document
          .getElementById("btn-undo")
          .addEventListener("click", () => HistoryManager.undo());
        document
          .getElementById("btn-redo")
          .addEventListener("click", () => HistoryManager.redo());
        DOM.toolbar.addEventListener("click", (e) => {
          if (!STATE.activeSticker) return;
          if (e.target.closest(".tool-control-wrapper")) return;

          const action = e.target.closest("button")?.dataset.action;
          if (!action) return;
          HistoryManager.save();
          const el = STATE.activeSticker;
          if (action === "flip") {
            el.dataset.f = parseInt(el.dataset.f) * -1;
            updateStickerTransform(el);
          } else if (action === "delete") {
            deleteSticker(el);
          }
          HistoryManager.save();
        });
      }

      function animationLoop(timestamp) {
        STATE.animatingStickers.forEach((anim) => {
          if (timestamp - anim.lastTime > anim.interval) {
            anim.current = (anim.current + 1) % anim.total;
            anim.lastTime = timestamp;
            if (anim.element)
              anim.element.src = getFramePath(anim.folder, anim.current);
          }
        });
        requestAnimationFrame(animationLoop);
      }

      function registerAnimation(el, folder, total) {
        if (el.dataset.isLight === "true") return;

        STATE.animatingStickers.push({
          element: el.querySelector("img"),
          folder: folder,
          total: parseInt(total),
          current: 0,
          lastTime: 0,
          interval: 1000 / CONFIG.defaultAnimFPS,
        });
      }

      function updateWorldTransform() {
        DOM.world.style.transform = `translate(${STATE.viewport.x}px, ${STATE.viewport.y}px) scale(${STATE.viewport.scale})`;
        if (STATE.activeSticker) syncSelectionHost(STATE.activeSticker);
      }

      function updateStickerTransform(el) {
        el.style.transform = `rotate(${el.dataset.r}deg) scale(${el.dataset.s}) scaleX(${el.dataset.f})`;
        if (STATE.activeSticker === el) syncSelectionHost(el);
      }

      function getEventPos(e) {
        if (e.touches && e.touches.length)
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }
      function screenToWorld(sx, sy) {
        return {
          x: (sx - STATE.viewport.x) / STATE.viewport.scale,
          y: (sy - STATE.viewport.y) / STATE.viewport.scale,
        };
      }

      const HistoryManager = {
        undoStack: [],
        redoStack: [],
        save() {
          const snapshot = JSON.stringify({
            bg: DOM.layerBg.innerHTML,
            deco: DOM.layerDeco.innerHTML,
          });
          if (
            this.undoStack.length > 0 &&
            this.undoStack[this.undoStack.length - 1] === snapshot
          )
            return;
          this.undoStack.push(snapshot);
          this.redoStack = [];
          this.updateUI();
        },
        restore(json) {
          const data = JSON.parse(json);
          DOM.layerBg.innerHTML = data.bg;
          DOM.layerDeco.innerHTML = data.deco;
          STATE.animatingStickers = [];
          document
            .querySelectorAll(".sticker-item[data-is-dynamic='true']")
            .forEach((el) => {
              if (el.dataset.isLight !== "true") {
                registerAnimation(
                  el,
                  el.dataset.animFolder,
                  el.dataset.animTotal,
                );
              }
            });
          deselectAll();
          this.updateUI();
          updateStickerBorderStyle();
        },
        undo() {
          if (!this.undoStack.length) return;
          this.redoStack.push(
            JSON.stringify({
              bg: DOM.layerBg.innerHTML,
              deco: DOM.layerDeco.innerHTML,
            }),
          );
          this.restore(this.undoStack.pop());
        },
        redo() {
          if (!this.redoStack.length) return;
          this.undoStack.push(
            JSON.stringify({
              bg: DOM.layerBg.innerHTML,
              deco: DOM.layerDeco.innerHTML,
            }),
          );
          this.restore(this.redoStack.pop());
        },
        updateUI() {
          document.getElementById("btn-undo").disabled =
            this.undoStack.length === 0;
          document.getElementById("btn-redo").disabled =
            this.redoStack.length === 0;
        },
      };

      init();
    </script>
  </body>
</html>